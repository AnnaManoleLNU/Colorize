# Chapter 2
These are my thoughts on the code quality of the Colorize project, as related to the book "Clean Code" by Robert Martin, chapter 2.

## Table of public identifiers and their explanations

| Identifier name and explanation | Reflection and rules from "Clean Code" |
| --- | --- |
| `ColorGenerator` <br /> Class name that is used to generate colors | **Use Intention-Revealing Names** <br /> The name of the class suggests its purpose, to generate colors. It is however not very specific, we do not know what kind of colors are generated,in which format or how we are to use them. In my opinion, it is still a name that is informative enough, because the methods in the class reveal its specificity (they add **meaningful context**). <br /> <br /> **Pick One Word per Concept** <br /> I have been using the word "generate" consistently throughout the project when a new color is created for the user. <br /> <br /> **Donâ€™t Add Gratuitous Context** <br /> In a project that is about colors adding the word Color in front of every class and method may seem unnecessary. I justify this because of "Colorize" being a module, which will be used in other applications. In this case it is important for the user to get a visual pointer that they are using functionality related to colors in their application. |
| `FontColorHelper` <br /> Class that has functionality related to font colors | **Use Intention-Revealing Names** <br /> The concept of a helper if quite abstract, it is unclear in which way the class helps with fonts. We can only make assumptions until we read the documentation or instantiate an object in order to use the public methods. <br /> <br /> **Make Meaningful Distinctions** <br /> This is the only class in my public interface that introduces the word "font", in order to distinguish that its functionality is above the other 2 public classes. |
| `generateLightColor/generateDarkColor(color)` <br /> Method name used to generate light/dark colors | **Use Intention-Revealing Names** <br /> The methods specify their functionality through the name. However it is not specified in which format the color is generated or what a light/dark color is defined as. For this the user has to read the documentation. I found it quite difficult to insert all the information required in a method name. <br /> <br /> **Use Pronounceable Names** <br /> As related to the previous point I tried to keep the names succinct while delivering information to the user. <br /> <br /> **Use Pronounceable Names** <br /> I did not use abbreviations, but tried to think about simple pronounceable words that the user might search for (**searchable names**). |
| `checkIfCompliantWithWCAGAA(color1, color2)` <br /> Method name that checks comparability with WCAG AA standards, between 2 colors | **Use Solution Domain Names** <br /> If a user (in this case familiar with web design/development) is looking for WCAG AA compatibility functionality, the method name offers just that. <br /> <br />  **Make Meaningful Distinctions** <br /> The method is very easily mistaken with another method which checks if the font is WCAG AAA compliant. The distinction is only one "A" and would lead to confusion and misuse of the 2 methods. <br /> <br /> **Use Intention-Revealing Names** <br /> It is also not specified what are we comparing in this method, or how many things we are comparing. The user would have to read the documentation. |
| `suggestWhiteOrBlackFont(color)` <br /> Method name that suggests white or black font | **Use Intention-Revealing Names** <br /> The functionality is self-explanatory. However, is it not obvious that the user has to enter a parameter for the method to suggest a white/black font. A better name would have been `suggestWhiteOrBlackFontFrom(color)` <br /> <br /> **Use Pronounceable Names** <br /> The method name is verbose and too paticular to solving a problem. All the words are fully spelled out so it is easy to understand what it does. |

## Overall reflection on Chapter 2 - Meaningful names
In the Colorize module class names have noun phrases, while method names contain verbs. This makes it so that the user can distinguish between object factories and functionality. The names are also descriptive enough to give the user a hint of what the class/method does. However, the names are not specific enough to give the user a full understanding of the functionality. For this the user has to read the documentation. It was difficult to think of an appropriate length for the names. In my opinion, extremely verbose names overcomplicated the code and make it difficult to read. On the other hand, short names are not descriptive enough. I tried to find a balance between the two. <br>
I did not use any puns or tried to be cute in my code, other than the README file where I tried to advertise the module to future programmers.  <br>
The name of the module may also be misleading because it does not apply colors to anything, it only generates them and provides font functionality. <br>
I used one word per concept, but I would it difficult in the case of the FontColorHelper class. Here I did not have the same functionality as the other 2 classes. <br>
The constructors of the classes do not use any arguments. This is to avoid confusion for the user. I wanted the module to be a simple color generator, in its first version. <br>
Because JavaScript is not a typed language, I gave the variables inside my methods names that specify their types. In the beginning I was using comments to specify the type of the variable, but I changed this because the target reader of my code would have some experience in programming.

# Chapter 3
These are my thoughts on the code quality of the Colorize project, as related the book "Clean Code" by Robert Martin, chapter 3. 

## Table with longest methods in the project and their explanations
_Note: Prettier was used to format the code, so formatting should keep a standard throughout the project. Some rows may only contain a character or a variable name. These add up to the number of lines. Whitespaces are not counted, neither are the comments._

| Method name and link | Number of lines (no whitespace) | Reflection and rules from "Clean Code" |
| --- | --- | --- |
| `calculateContrastRatio(color1, color2)` <br /> [FontColorHelper.js](./lib/js/FontColorHelper.js) | 13 | **Keep your functions small** <br /> The methods has 13 rows and the if/else blocks only use one level of indentation. <br /> <br /> **Do one thing** <br /> The method calculates the contrast ratio between 2 colors and returns it. However, to achieve this, the method establishes which color is the dark light one. The method could have been split into 2. One to decide the darker/lighter color and one to calculate it using this information. <br /> <br /> **Function Arguments** <br /> The number of arguments to the method is dyadic. The order of the arguments does not matter since this is resolved in the method. However a method with 0 parameters could have been used if the variables were stored inside the constructor. This is a poor solution since I would have to initialize FontColorHelper objects more often. |
| `suggestWhiteOrBlackFont(backgroundColor)` <br /> [FontColorHelper.js](./lib/js/FontColorHelper.js) | 15 | **Use descriptive names** <br />  <br /> The method does what the name states, it does not alter anything, simply suggests a white or black font color, given a background color. <br /> **Do one thing** <br /> The method suggests a white or black font color for a given background color. To do this it calculated the contrastRatio between the background color and white or black. These calculations could have been broken apart into their separate function. <br /> <br /> **Keep your functions small** <br /> Using the constants white and black in the class private field would have been appropriate and made the method smaller. In the case of a font color helper, it would have been appropriate to store white and black as private fields. |
| `generateClockwise(color)` <br /> [ColorSchemeGenerator.js](./lib/js/ColorSchemeGenerator.js) | 17 | **Common Monadic Forms** <br /> The parameter name is confusing in combination with the method name. A better name would have been `generateClockwiseColorFrom(color)` <br /> <br /> **Do one thing** <br /> The method generates a color that is clockwise from the given color. In order to do this it adds to red, green, or blue depending on which is the highest. These operations could have been broken down into their own separate methods according to the book. |
| `generateCounterClockwise(color)` <br /> [ColorSchemeGenerator.js](./lib/js/ColorSchemeGenerator.js) | 17 |**Common Monadic Forms** <br />  The parameter name is confusing in combination with the method name. A better name would have been `generateCounterClockwiseColorFrom(color)`  <br />  <br />  **DRY - don't repeat yourself** <br /> The method similar to `generateClockwise(color)` except it adds to rgb in counter clockwise fashion. Since the same values (add 20) were used, we could have used an algorithm to add clockwise or counter clockwise to the rgb. This however may have effects on the readability of the code. |
| `#calculateLuminance(color)` <br /> [FontColorHelper.js](./lib/js/FontColorHelper.js) | 25 | **Keep your functions small** <br /> At 25 lines of code the function is the largest in the project. Several mathematical calculations are done and the numbers could be confusing to the user without visiting the link provided. The indentation makes it so that the function is larger. Severals rows of code could have been written together. <br /> <br /> **Do one thing** <br /> The method does calculates the luminance of a color. It features transforming a string into an array of rgb integers in order to work with the values, thus not doing only one thing. The logic for this could have been broken down into its separate private function. 

## Overall reflection on Chapter 3 - Functions
While I do agree that several functions(methods) in my project could have been shorter by using private fields and breaking down the logic into smaller functions, I do not agree that this would have made the code more readable. Personally, hopping around between files and different methods just to go through the steps of a function is more confusing, even if the names of the functions explain them perfectly. <br>

 There are cases in which a method is unnecessarily cluttered with operations (calculating luminance requires that the string be made into an array of integers). In this case I do agree with the book, that I should have split the method into 2. On the other hand, this operation is used no where else in the file. Arguably, since I am performing the same operation in color scheme generator, I could have just created a class that is not a part of the public interface, where I handle operations on the strings I pass in. I believe that in a small project such as this, it would not have increased readability. If the project is planned to grow however, that would have been a very useful class to import into the other classes. <br>

I do not agree with the book that a method should have only one level of abstraction. It is easier to follow the logic if a single method goes through the steps in the same place. There are levels to this of course and everyone has their preference. I still believe a function could be too long, but I do not think we can set a specific number of lines of code. To me, if it feels like it is part of the same uninterrupted process, it should be in the same function. If you it is required to do A before B always, it should be in the same function. <br>

As for arguments go, I think it's easier to use a function with no arguments but it is not necessarily easier to understand. Using parameters could also help get rid of code that repeats itself. In that way you pass in the argument required when you call the function depending on the situation. <br>

I do agree that having side effects to functions is not something one should do, but instead link the logic together so that things happen as consequence of other things. As projects get larger, this is more difficult to maintain and probably how unexpected bugs occur. So I would say, it is one rule I agree the most with and it's even more crucial in larger projects. At the same time splitting code everywhere is more difficult in larger projects. <br>

I do not agree that mixing different levels of abstractions in a function is bad. I may have a function that does a complex step that I want to reuse in other functions. I do not want to repeat the code, so I would just call the function in the main function. Having functions that are an amalgamation of other functions (same level of abstraction) requires the reader to jump about in code, which in my opinion always more confusing. And how would a function that calls several functions do only one thing? By default it does several things. <br>

# Overall reflection on the project's code quality

In my opinion, having the method be split into several small methods that do one thing should only be used if we want to reuse those small methods to perform operations into other similar methods. Preparing for extended functionality that is not (and probably will never be) on the agenda is not an effective use of time. Instead I would apply refactoring when needed (for example, if I need to use the same bit of code else where).

I find it easier to read code top to bottom, when it's not split up into several places. But then again longer methods tend to also be confusing and illegible so I believe there should be a compromise here. My strategy so far has been commenting the obvious different steps of a method, that way I can split it internally.

Of course, side effects would have to be considered when you write a method that does several things. Splitting the methods into several small ones that do one thing implies hopping around in your code and making sure those methods deliver on their promises anyway (assuming that the method names are explicit enough). 

Defining what a class does was somewhat difficult in my project, in the case of the FontColorHelper. Here it was difficult determining which private fields to declare inside it. Overall, I chose to have constructors with no arguments, because I wanted the user to use the methods for the functionality they needed. I did not want to force the user to create objects with arguments that they may not need. I think it's easier to think about one method at a time, rather than a whole class. This is why my methods have parameters, but my classes do not.

In the end, the problem is not if I can understand my own code (because I would use a strategy that suits me), the problem is finding a way for my code to communicate its intent to the target reader.