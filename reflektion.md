# Chapter 2
These are my thoughts on the code quality of the Colorize project, as related the book "Clean Code" by Robert Martin, chapter 2.

## Table of public identifiers and their explanations

| Identifier name and explanation | Reflection and rules from "Clean Code" |
| --- | --- |
| `ColorGenerator` <br /> Class name that is used to generate colors | **Use Intention-Revealing Names** <br /> The name of the class suggests its purpose, to generate colors. It is however not very specific, we do not know what kind of colors are generated,in which format or how we are to use them. In my opinion, it is still a name that is informative enough, because the methods in the class reveal its specificity (they add **meaningful context**). <br /> <br /> **Pick One Word per Concept** <br /> I have been using the word "generate" consistently throughout the project when a new color is created for the user. <br /> <br /> **Donâ€™t Add Gratuitous Context** <br /> In a project that is about colors adding the word Color in front of every class and method may seem unnecessary. I justify this because of "Colorize" being a module, which will be used in other applications. In this case it is important for the user to get a visual pointer that they are using functionality related to colors in their application. |
| `FontColorHelper` <br /> Class that has functionality related to font colors | **Use Intention-Revealing Names** <br /> The concept of a helper if quite abstract, it is unclear in which way the class helps with fonts. We can only make assumptions until we read the documentation or instantiate an object in order to use the public methods. <br /> <br /> **Make Meaningful Distinctions** <br /> This is the only class in my public interface that introduces the word "font", in order to distinguish that its functionality is above the other 2 public classes. |
| `generateLightColor/generateDarkColor(color)` <br /> Method name used to generate light/dark colors | **Use Intention-Revealing Names** <br /> The methods specify their functionality through the name. However it is not specified in which format the color is generated or what a light/dark color is defined as. For this the user has to read the documentation. I found it quite difficult to insert all the information required in a method name. <br /> <br /> **Use Pronounceable Names** <br /> As related to the previous point I tried to keep the names succint while delivering information to the user. <br /> <br /> **Use Pronounceable Names** <br /> I did not use abbreviations, but tried to think about simple pronounceable words that the user might search for (**searchable names**). |
| `checkIfCompliantWithWCAGAA(color1, color2)` <br /> Method name that checks compliability with WCAG AA standards, between 2 colors | **Use Solution Domain Names** <br /> If a user (in this case familiar with web design/development) is looking for WCAG AA compatibility functionality, the method name offers just that. <br /> <br />  **Make Meaningful Distinctions** <br /> The method is very easily mistaken with another method which checks if the font is WCAG AAA compliant. The distinction is only one "A" and would lead to confusion and missuse of the 2 methods. <br /> <br /> **Use Intention-Revealing Names** <br /> It is also not specified what are we comparing in this method, or how many things we are comparing. The user would have to read the documentation. |
| `suggestWhiteOrBlackFont(color)` <br /> Method name that suggests white or black font | **Use Intention-Revealing Names** <br /> The functionality is self-explanatory. However, is it not obvious that the user has to enter a parameter for the method to suggest a white/black font. A better name would have been `suggestWhiteOrBlackFontFrom(color)` <br /> <br /> **Use Pronounceable Names** <br /> The method name is verbose and too paticular to solving a problem. All the words are fully spelled out so it is easy to understand what it does. |

## Overall reflection on Chapter 2 - Meaningful names
In the Colorize module class names have noun phrases, while method names contain verbs. This makes it so that the user can distinguish between object factories and functionality. The names are also descriptive enough to give the user a hint of what the class/method does. However, the names are not specific enough to give the user a full understanding of the functionality. For this the user has to read the documentation. It was difficult to think of an appropriate length for the names. In my opinion, extremely verbose names overcomplicate the code and make it difficult to read. On the other hand, short names are not descriptive enough. I tried to find a balance between the two. <br>
I did not use any puns or tried to be cute in my code, other than the README file where I tried to advertise the module to future programmers.  <br>
The name of the module may also be misleading because it does not apply colors to anything, it only generates them and provides font functionality. <br>
I used one word per concept, but I would it difficult in the case of the FontColorHelper class. Here I did not have the same functionality as the other 2 classes. <br>
The constructors of the classes do not use any arguments. This is to avoid confusion for the user. I wanted the module to be a simple color generator, in its first version. <br>
Because JavaScript is not a typed language, I gave the variables inside my methods names that specifiy their types. In the beggining I was using comments to specify the type of the variable, but I changed this because the target reader of my code would have some experience in programming.

# Chapter 3
These are my thoughts on the code quality of the Colorize project, as related the book "Clean Code" by Robert Martin, chapter 3. 

## Table with longest methods in the project and their explanations
_Note: Prettier was used to format the code, so formating should keep a standard throughout the project. Some rows may only contain a character or a variable name. These add up to the number of lines. Whitespaces are not counted, neither are the comments._

| Method name and link | Number of lines (no whitespace) | Reflection and rules from "Clean Code" |
| --- | --- | --- |
| `calculateContrastRatio(color1, color2)` <br /> [FontColorHelper.js](./lib/js/FontColorHelper.js) | 13 | **Keep your functions small** <br /> The methods has 13 rows and the if/else blocks only use one level of indentation. <br /> <br /> **Do one thing** <br /> The method calculates the contrast ratio between 2 colors and returns it. However, to achieve this, the method establishes which color is the dark light one. The method could have been split into 2. One to decide the darker/lighter color and one to calculate it using this information. <br /> <br /> **Function Arguments** <br /> The number of arguments to the method is dyadic. The order of the arguments does not matter since this is resolved in the method. However a method with 0 parameters could have been used if the variables were stored inside the constructor. This is a poor solution since I would have to initialize FontColorHelper objects more often. |
| `suggestWhiteOrBlackFont(backgroundColor)` <br /> [FontColorHelper.js](./lib/js/FontColorHelper.js) | 15 | **Use descriptive names** <br />  <br /> The method does what the name states, it does not alter anything, simply suggests a white or black font color, given a background color. <br /> **Do one thing** <br /> The method suggests a white or black font color for a given background color. To do this it calculated the contrastRatio between the background color and white or black. These calculations could have been broken apart into their separate function. <br /> <br /> **Keep your functions small** <br /> Using the constants white and black in the class private field would have been appropriate and made the method smaller. In the case of a font color helper, it would have been appropriate to store white and black as private fields. |
| `generateClockwise(color)` <br /> [ColorSchemeGenerator.js](./lib/js/ColorSchemeGenerator.js) | 17 | **Common Monadic Forms** <br /> The parameter name is confusing in combination with the method name. A better name would have been `generateClockwiseColorFrom(color)` <br /> <br /> **Do one thing** <br /> The method generates a color that is clockwise from the given color. In order to do this it adds to red, green, or blue depending on which is the highest. These operations could have been broken down into their own separate methods according to the book. |
| `generateCounterClockwise(color)` <br /> [ColorSchemeGenerator.js](./lib/js/ColorSchemeGenerator.js) | 17 |**Common Monadic Forms** <br />  The parameter name is confusing in combination with the method name. A better name would have been `generateCounterClockwiseColorFrom(color)`  <br />  <br />  **DRY - don't repeat yourself** <br /> The method similar to `generateClockwise(color)` except it adds to rgb in counter clockwise fashion. Since the same values (add 20) were used, we could have used an algorithm to add clockwise or counter clockwise to the rgb. This however may have effects on the redability of the code. |
| `#calculateLuminance(color)` <br /> [FontColorHelper.js](./lib/js/FontColorHelper.js) | 25 | **Keep your functions small** <br /> At 25 lines of code the function is the largest in the project. Several mathematical calculations are done and the numbers could be confusing to the user without visiting the link provided. The intendation makes it so that the function is larger. Severals rows of code could have been written together. <br /> <br /> **Do one thing** <br /> The method does calculates the luminance of a color. It features transforming a string into an array of rgb integers in order to work with the values, thus not doing only one thing. The logic for this could have been broken down into its separate private function. 

## Overall reflection on Chapter 3 - Functions

# Overall reflection on the project's code quality